(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "24-May-2023 10:22:55" {DSK}<home>medley>il>BRAINCONS.;44 21067  

      :EDIT-BY "PA"

      :CHANGES-TO (FNS BRC.VM.RUN BRC.VM.PREVNEXT)
                  (VARS BRAINCONSCOMS)

      :PREVIOUS-DATE "24-May-2023 09:08:56" {DSK}<home>medley>il>BRAINCONS.;43)


(PRETTYCOMPRINT BRAINCONSCOMS)

(RPAQQ BRAINCONSCOMS
       ((RECORDS BRANCH BRC.ERROR BRC.PROGRAM BRC.VM)
        (FNS BRC.BRANCHP BRC.MAKE.JNZ BRC.MAKE.JZ BRC.MAKE.VM BRC.PARSE BRC.PARSE.INSTRUCTION 
             BRC.VALIDATE.BRANCHES BRC.VM.INCDEC BRC.VM.LOAD BRC.VM.PREVNEXT BRC.VM.RESET BRC.VM.RUN)
        (VARS (BRC.MAXIP 30000)
              (* Maximum number of instructions in a program.))
        (INITVARS (BRC.MEMSIZE 30000)
               (* Number of memory cells.))))
(DECLARE%: EVAL@COMPILE

(RECORD BRANCH 

         (* A branch instruction consisting of a MNEMONIC, the index ADDRESS in the 
         instructions array, the DESTINATION address, and the SRCPTR index of the branch 
         command in the source string.)

               (MNEMONIC ADDRESS DESTINATION SRCPTR))

(RECORD BRC.ERROR 

         (* An error caused by REASON, a symbol, occurring at the SRCIDX character index 
         in the source and at ADDRESS in the program, if applicable.)

                  (REASON SRCIDX ADDRESS))

(RECORD BRC.PROGRAM 

         (* Intermediate program representation holding an array of INSTRUCTIONS, the 
         index LASTIP of the last instruction in the array, a list of branch instructions, 
         a list of BRC.ERROR parse errors, and the SOURCE code as a string.)

                    (INSTRUCTIONS LASTIP BRANCHES ERRORS SOURCE))

(RECORD BRC.VM 

         (* A record representing a Brainfuck Virtual Machine that holds the main memory, 
         I/O streams, and a program.)

               (PROGRAM                                      (* 
                                                             #.(SEDIT::MAKE-BROKEN-ATOM "PROGRAM:") 
                                                             program, a BRC.PROGRAM)
                      IP                                     (* #.(SEDIT::MAKE-BROKEN-ATOM "IP:") 
                                                             program counter, the address of the 
                                                             next instruction)
                      MEMORY                                 (* 
                                                             #.(SEDIT::MAKE-BROKEN-ATOM "MEMORY:") 
                                                             0-based array of BRC.MEMSIZE memory 
                                                             cells holding 8-bit values)
                      DATAPTR                                (* 
                                                             #.(SEDIT::MAKE-BROKEN-ATOM "DATAPTR:") 
                                                             index of the memory cell the next 
                                                             instruction acts on)
                      STATE

         (* #.(SEDIT::MAKE-BROKEN-ATOM "STATE:") the state of the VM, one of READY %(ready 
         to load or run a program, or after program execution terminated with no errors%) 
         or a BRC.ERROR describing a runtime error)

                      IN                                     (* #.(SEDIT::MAKE-BROKEN-ATOM "IN:") 
                                                             stream to get program input, NIL by 
                                                             default)
                      OUT                                    (* #.(SEDIT::MAKE-BROKEN-ATOM "OUT:") 
                                                             stream to display program output, NIL 
                                                             by default)
                      ))
)
(DEFINEQ

(BRC.BRANCHP
  [LAMBDA (INSTRUCTION)                                      (* ; "Edited 15-Mar-2023 11:25 by PA")
                                                             (* ; "Edited 26-Feb-2023 09:03 by PA")
                                                             (* Returns T if INSTRUCTION is a 
                                                             branch instruction.)
    (AND (LISTP INSTRUCTION)
         (EQ (LENGTH INSTRUCTION)
             4)
         (LET ((MNEMONIC (fetch (BRANCH MNEMONIC) of INSTRUCTION)))
              (AND (LITATOM MNEMONIC)
                   (OR (EQ MNEMONIC 'JZ)
                       (EQ MNEMONIC 'JNZ])

(BRC.MAKE.JNZ
  [LAMBDA (SRC.IDX ADDR PROGRAM)                             (* ; "Edited 15-Mar-2023 11:27 by PA")
                                                             (* ; "Edited  4-Mar-2023 10:44 by PA")
                                                             (* ; "Edited 26-Feb-2023 09:14 by PA")

         (* Creates and returns the JNZ instruction at position SRC.IDX in the source 
         string, taking care of backpatching the destination address of the matching JZ 
         instruction and updating the branches and errors of PROGRAM.
         Uses the free variable BRC.BRANCH.STACK.)

    (LET ((JZ (pop BRC.BRANCH.STACK))
          (INSTRUCTION (create BRANCH
                              MNEMONIC _ 'JNZ
                              ADDRESS _ ADDR
                              SRCPTR _ SRC.IDX)))
         (if (AND (BRC.BRANCHP JZ)
                  (EQ (fetch (BRANCH MNEMONIC) of JZ)
                      'JZ))
             then (replace (BRANCH DESTINATION) of JZ with (ADD1 ADDR))
                  (replace (BRANCH DESTINATION) of INSTRUCTION with (ADD1 (fetch (BRANCH ADDRESS)
                                                                             of JZ)))
           else (push (fetch (BRC.PROGRAM ERRORS) of PROGRAM)
                      (create BRC.ERROR
                             REASON _ 'UNMATCHEDBRANCH
                             SRCIDX _ SRC.IDX
                             ADDRESS _ ADDR)))
         (push (fetch (BRC.PROGRAM BRANCHES) of PROGRAM)
               INSTRUCTION)
         INSTRUCTION])

(BRC.MAKE.JZ
  [LAMBDA (SRC.IDX ADDR PROGRAM)                             (* ; "Edited 15-Mar-2023 11:04 by PA")
                                                             (* ; "Edited  4-Mar-2023 10:46 by PA")
                                                             (* ; "Edited 25-Feb-2023 11:08 by PA")

         (* Creates and returns the JZ instruction at position SRC.IDX in the source 
         string #.(SEDIT::MAKE-BROKEN-ATOM ",") leaving the destination address 
         unspecified at 0 for later backpatching and updating the branches of PROGRAM.
         Uses the free variable BRC.BRANCH.STACK.)
                                                             (* ; "Edited 25-Feb-2023 11:01 by PA")
    (LET ((INST (create BRANCH
                       MNEMONIC _ 'JZ
                       ADDRESS _ ADDR
                       DESTINATION _ 0
                       SRCPTR _ SRC.IDX)))
         (push BRC.BRANCH.STACK INST)
         (push (fetch (BRC.PROGRAM BRANCHES) of PROGRAM)
               INST)
         INST])

(BRC.MAKE.VM
  [LAMBDA NIL                                                (* ; "Edited 21-May-2023 08:54 by PA")
                                                             (* ; "Edited  7-May-2023 10:09 by PA")

         (* Creates a VM. Returns the new VM with memory initialized to null bytes and no 
         program loaded.)

    (create BRC.VM
           PROGRAM _ NIL
           IP _ 1
           MEMORY _ (ARRAY BRC.MEMSIZE 'FIXP 0 0)
           DATAPTR _ 0
           STATE _ 'READY
           IN _ NIL
           OUT _ NIL])

(BRC.PARSE
  [LAMBDA (SOURCE)                                           (* ; "Edited  5-May-2023 06:59 by PA")
                                                             (* ; "Edited 11-Mar-2023 09:21 by PA")
                                                             (* ; "Edited  5-Mar-2023 10:46 by PA")
                                                             (* ; "Edited 26-Feb-2023 09:13 by PA")
                                                             (* ; "Edited 21-Feb-2023 10:49 by PA")
                                                             (* ; "Edited 18-Feb-2023 11:26 by PA")
                                                             (* ; "Edited  9-Feb-2023 10:19 by PA")
                                                             (* ; "Edited  6-Feb-2023 08:55 by PA")

         (* Parses the SOURCE string of a program and returns a BRC.PROGRAM record holding 
         the internal representation of the program and its instructions.
         Sets the ERRORS field of BRC.PROGRAM in case of parse errors, and also if SOURCE 
         is null or has more instructions than available memory.
         Binds the free variable BRC.BRANCH.STACK used by the called functions.)

    (PROG ((LASTIDX (NCHARS SOURCE))
           INST INSTS (ADDR 0)
           BRC.BRANCH.STACK)

         (* LASTIDX <= 0 Null source string, empty program.
         LASTIDX > BRC.MAXIP More instructions than available memory)

          (if (OR (ILEQ LASTIDX 0)
                  (GREATERP LASTIDX BRC.MAXIP))
              then (RETURN (create BRC.PROGRAM
                                  ERRORS _ (LIST (BRC.MAKE.ERROR 'INVALIDMEMORY LASTIDX LASTIDX))
                                  LASTIP _ 0
                                  SOURCE _ SOURCE)))
          (SETQ INSTS (ARRAY LASTIDX 'POINTER))
          (SETQ PARSED (create BRC.PROGRAM
                              INSTRUCTIONS _ INSTS
                              LASTIP _ 0
                              SOURCE _ SOURCE))

         (* ADDR hasn't been incremented yet to point to the current instruction when the 
         loop condition is tested by calling BRC.PARSE.INSTRUCTION, so add 1 to the 
         latter's argument address to account for this.)

          (for CHRIDX from 1 to LASTIDX when (SETQ INST (BRC.PARSE.INSTRUCTION (SUBSTRING SOURCE 
                                                                                      CHRIDX CHRIDX)
                                                               CHRIDX
                                                               (ADD1 ADDR)
                                                               PARSED))
             do (SETQ ADDR (ADD1 ADDR))
                (SETA INSTS ADDR INST))
          (replace (BRC.PROGRAM LASTIP) of PARSED with ADDR)
          (BRC.VALIDATE.BRANCHES PARSED)                     (* SOURCE contains no instructions, 
                                                             possibly only comments.)
          [if (ILEQ ADDR 0)
              then (replace (BRC.PROGRAM ERRORS) of PARSED with (LIST (BRC.MAKE.ERROR 'INVALIDMEMORY
                                                                             LASTIDX ADDR]
          (RETURN PARSED])

(BRC.PARSE.INSTRUCTION
  [LAMBDA (SRC.CHAR SRC.IDX ADDRESS PROGRAM)                 (* ; "Edited 15-Mar-2023 11:04 by PA")
                                                             (* ; "Edited  4-Mar-2023 10:34 by PA")
                                                             (* ; "Edited 26-Feb-2023 09:19 by PA")
                                                             (* ; "Edited 21-Feb-2023 11:03 by PA")
                                                             (* ; "Edited  9-Feb-2023 10:32 by PA")
                                                             (* ; "Edited  5-Feb-2023 10:49 by PA")

         (* Parses the single character string SRC.CHAR at index SRC.IDX of the source of 
         PROGRAM and returns the corresponding instruction at ADDRESS, or NIL if the 
         character is not recognized.)

    (SELECTQ (MKATOM SRC.CHAR)
        (> 'NEXT)
        (< 'PREV)
        (+ 'INC)
        (- 'DEC)
        (%. 'IN)
        (%, 'OUT)
        (%[ (BRC.MAKE.JZ SRC.IDX ADDRESS PROGRAM))
        (%] (BRC.MAKE.JNZ SRC.IDX ADDRESS PROGRAM))
        NIL])

(BRC.VALIDATE.BRANCHES
  [LAMBDA (PROGRAM)                                          (* ; "Edited 11-Mar-2023 10:02 by PA")

         (* Checks for errors the branches of PROGRAM, adds any entries to the error list 
         of PROGRAM, and returns the list of errors.)

    (LET* [(BRANCHES (fetch (BRC.PROGRAM BRANCHES) of PROGRAM))
           (LASTIP (fetch (BRC.PROGRAM LASTIP) of PROGRAM))
           (ERRORS (for BRANCH in BRANCHES when (OR (LESSP (fetch (BRANCH DESTINATION) of BRANCH)
                                                           1)
                                                    (GREATERP (fetch (BRANCH DESTINATION)
                                                                 of BRANCH)
                                                           LASTIP))
                      collect (create BRC.ERROR
                                     REASON _ 'OUTOFBOUNDS
                                     ADDRESS _ (fetch (BRANCH ADDRESS) of BRANCH]
          (if ERRORS
              then (replace (BRC.PROGRAM ERRORS) of PROGRAM with (APPEND (fetch (BRC.PROGRAM ERRORS)
                                                                            of PROGRAM)
                                                                        ERRORS)))
          ERRORS])

(BRC.VM.INCDEC
  [LAMBDA (VM OPCODE)                                        (* ; "Edited 21-May-2023 08:57 by PA")

         (* Executes the INC or DEC instruction of the Brainfuck program in virtual 
         machine VM depending on the corresponding symbol OPCODE.
         Doesn't generate runtime errors. Returns VM.)

    (LET* ((CURVAL (ELT (fetch (BRC.VM MEMORY) of VM)
                        (fetch (BRC.VM DATAPTR) of VM)))
           (NEWVAL (SELECTQ OPCODE
                       (INC (ADD1 CURVAL))
                       (DEC (SUB1 CURVAL))
                       CURVAL)))
          (SETA (fetch (BRC.VM MEMORY) of VM)
                (fetch (BRC.VM DATAPTR) of VM)
                (COND
                   ((GREATERP NEWVAL 127)
                    -128)
                   ((LESSP NEWVAL -128)
                    127)
                   (T NEWVAL)))
          VM])

(BRC.VM.LOAD
  [LAMBDA (VM PROGRAM)                                       (* ; "Edited  7-May-2023 10:14 by PA")
                                                             (* ; "Edited  6-May-2023 10:13 by PA")

         (* Loads PROGRAM into VM and prepares the machine to start the program.
         PROGRAM is a BRC.PROGRAM. Returns VM.)

    (replace (BRC.VM PROGRAM) of VM with PROGRAM)
    (replace (BRC.VM IP) of VM with 1)
    (replace (BRC.VM STATE) of VM with 'READY)
    VM])

(BRC.VM.PREVNEXT
  [LAMBDA (VM OPCODE)                                        (* ; "Edited 24-May-2023 10:12 by PA")

         (* Executes the PREV or NEXT instruction of the Brainfuck program in virtual 
         machine VM depending on the corresponding OPCODE.
         Generates OUTOFBOUNDS error if the memory pointer ends up pointing outside of the 
         memory space. Returns VM.)

    (LET* ((CURPTR (fetch (BRC.VM DATAPTR) of VM))
           (NEWPTR (SELECTQ OPCODE
                       (PREV (SUB1 CURPTR))
                       (NEXT (ADD1 CURPTR))
                       CURPTR)))
          (if (AND (GEQ NEWPTR 0)
                   (LEQ NEWPTR BRC.MEMSIZE))
              then (replace (BRC.VM DATAPTR) of VM with NEWPTR)
            else (replace (BRC.VM STATE) of VM with (create BRC.ERROR
                                                           REASON _ 'OUTOFBOUNDS
                                                           ADDRESS _ NEWPTR)))
          VM])

(BRC.VM.RESET
  [LAMBDA (VM CLEARPROG)                                     (* ; "Edited 20-May-2023 08:59 by PA")
                                                             (* ; "Edited  7-May-2023 10:37 by PA")
                                                             (* ; "Edited  6-May-2023 10:21 by PA")

         (* Clears the memory of VM to null bytes, and deletes any stored program if 
         CLEARPROG is T instead of the default NIL.
         VM is initialized to restart the program, or load a new one if CLEARPROG is T.
         Returns VM.)

    (bind (MEMORY _ (fetch (BRC.VM MEMORY) of VM)) for MEMPTR from 0 to (SUB1 BRC.MEMSIZE)
       do (SETA MEMORY MEMPTR 0))
    (replace (BRC.VM IP) of VM with 1)
    (replace (BRC.VM DATAPTR) of VM with 0)
    (replace (BRC.VM STATE) of VM with 'READY)
    (if CLEARPROG
        then (replace (BRC.VM PROGRAM) of VM with NIL))
    VM])

(BRC.VM.RUN
  [LAMBDA (VM STEPS)                                         (* ; "Edited 24-May-2023 10:14 by PA")
                                                             (* ; "Edited 21-May-2023 08:38 by PA")
                                                             (* ; "Edited 14-May-2023 10:04 by PA")
                                                             (* ; "Edited  6-May-2023 10:16 by PA")

         (* VM runs the program until the end if STEPS is NIL, otherwise executes the next 
         STEPS instructions. A runtime error terminates the program.
         Returns VM.)

    (LET* [(PROGRAM (fetch (BRC.VM PROGRAM) of VM))
           (ENDIDX (fetch (BRC.PROGRAM LASTIP) of PROGRAM))
           (MAXSTEPS (if STEPS
                         then (MIN STEPS ENDIDX]

         (* The VM runs only if there is a program, the machine is ready, and the IP 
         hasn't reached the end of the program yet.)

          [AND PROGRAM (EQ (fetch (BRC.VM STATE) of VM)
                           'READY)
               (LEQ (fetch (BRC.VM IP) of VM)
                    ENDIDX)
               (bind (I _ 1)
                     (MNEMONIC _ NIL)
                     (PC _ 1) while (OR (AND (NULL STEPS)
                                             (LEQ (fetch (BRC.VM IP) of VM)
                                                  ENDIDX))
                                        (AND STEPS (LEQ I MAXSTEPS)))
                  do (SETQ INSTRUCTION (ELT (fetch (BRC.PROGRAM INSTRUCTIONS) of PROGRAM)
                                            (fetch (BRC.VM IP) of VM)))
                     (SETQ MNEMONIC (if (LITATOM INSTRUCTION)
                                        then INSTRUCTION
                                      else (fetch (BRANCH MNEMONIC) of INSTRUCTION)))
                     (SETQ PC (fetch (BRC.VM IP) of VM))
                     (PRINTOUT T "I:" %, I %, "MAXSTEPS" %, MAXSTEPS %, "IP:" %, PC %, "ENDIDX:" %, 
                            ENDIDX %, "MNEMONIC:" %, .PPV MNEMONIC T)
                     (SELECTQ MNEMONIC
                         (NEXT (PRINTOUT T "Executing" %, MNEMONIC T)
                               (BRC.VM.PREVNEXT VM 'NEXT))
                         (PREV (PRINTOUT T "Executing" %, MNEMONIC T)
                               (BRC.VM.PREVNEXT VM 'PREV))
                         (INC (PRINTOUT T "Executing" %, MNEMONIC T)
                              (BRC.VM.INCDEC VM 'INC))
                         (DEC (PRINTOUT T "Executing" %, MNEMONIC T)
                              (BRC.VM.INCDEC VM 'DEC))
                         (IN (PRINTOUT T "Executing" %, MNEMONIC T))
                         (OUT (PRINTOUT T "Executing" %, MNEMONIC T))
                         (JZ (PRINTOUT T "Executing" %, MNEMONIC T))
                         (JNZ (PRINTOUT T "Executing" %, MNEMONIC T))
                         NIL)
                     (if (AND STEPS (LEQ I MAXSTEPS))
                         then (SETQ I (ADD1 I)))
                     (replace (BRC.VM IP) of VM with (ADD1 PC]
          VM])
)

(RPAQQ BRC.MAXIP 30000)

(RPAQ? BRC.MEMSIZE 30000)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (4075 20984 (BRC.BRANCHP 4085 . 4779) (BRC.MAKE.JNZ 4781 . 6477) (BRC.MAKE.JZ 6479 . 
7590) (BRC.MAKE.VM 7592 . 8159) (BRC.PARSE 8161 . 11577) (BRC.PARSE.INSTRUCTION 11579 . 12744) (
BRC.VALIDATE.BRANCHES 12746 . 14141) (BRC.VM.INCDEC 14143 . 15081) (BRC.VM.LOAD 15083 . 15635) (
BRC.VM.PREVNEXT 15637 . 16700) (BRC.VM.RESET 16702 . 17731) (BRC.VM.RUN 17733 . 20982)))))
STOP
